#!/usr/bin/env nu
# Link WSL kubeconfig to Windows kubeconfig for seamless kubectl usage

{{- if and (eq .chezmoi.os "linux") (eq .chezmoi.osRelease.id "nixos-wsl") }}

print "üîó Setting up shared kubeconfig between WSL and Windows..."

# Get Windows username from path
let win_user_result = do { cmd.exe /c "echo %USERNAME%" } | complete

if $win_user_result.exit_code != 0 {
    print "‚ùå Could not determine Windows username"
    exit 0
}

let win_user = $win_user_result.stdout | str trim

if ($win_user | is-empty) {
    print "‚ùå Windows username is empty"
    exit 0
}

# Windows kubeconfig path (accessible from WSL)
let win_kube_dir = $"/mnt/c/Users/($win_user)/.kube"
let win_kube_config = $"($win_kube_dir)/config"

# WSL kubeconfig path
let wsl_kube_dir = $"($nu.home-path)/.kube"
let wsl_kube_config = $"($wsl_kube_dir)/config"

# Create WSL .kube directory if it doesn't exist
if not ($wsl_kube_dir | path exists) {
    mkdir $wsl_kube_dir
}

# Check if Windows kubeconfig exists
if not ($win_kube_config | path exists) {
    print $"‚ÑπÔ∏è  Windows kubeconfig not found at ($win_kube_config)"
    print "   Configure kubectl on Windows first, then run 'chezmoi apply' again"
    exit 0
}

# Remove existing config if it's a regular file (not a symlink)
if ($wsl_kube_config | path exists) {
    let path_type = ls -l $wsl_kube_config | get 0.type
    if $path_type != "symlink" {
        print $"‚ö†Ô∏è  Backing up existing kubeconfig to ($wsl_kube_config).backup"
        mv $wsl_kube_config $"($wsl_kube_config).backup"
    } else {
        rm $wsl_kube_config
    }
}

# Create symlink
let result = do { ln -s $win_kube_config $wsl_kube_config } | complete
if $result.exit_code == 0 {
    print $"‚úÖ Linked ($wsl_kube_config) ‚Üí ($win_kube_config)"
} else {
    print $"‚ùå Could not create symlink"
}

{{- end }}
