# CLAUDE.md - Chezmoi Scripts

This directory contains scripts that run during `chezmoi apply`.

## Script Types

### run_once_ Scripts

Execute only once. State tracked in chezmoi's database.

- Example: `run_once_install-tool.sh`

### run_onchange_ Scripts

Execute when script content changes.

- Example: `run_onchange_configure-service.sh.tmpl`

### run_after_ Scripts

Execute after all files are applied.

- Example: `run_after_reload-config.sh`

## Current Scripts

### run_onchange_linux-systemd-user-services.nu.tmpl

- **Purpose**: Consolidated systemd user service symlink management
- **Services Managed**:
  - `syncthing.service` - File synchronization (all machines)
  - `ssh-agent.service` - SSH agent (headless machines only)
- **Pattern**: Resolves Nix store paths and creates/updates symlinks
- **Features**:
  - Auto-updates when NixOS rebuilds (new Nix store paths)
  - Conditional service management (desktop vs headless)
  - Automatic service enabling and starting

### run_onchange_linux-autostart-desktop-files.nu.tmpl

- **Purpose**: Manage desktop autostart entries (desktop machines only)
- **Pattern**: Link to system desktop files or create custom ones
- **Applications**: Firefox, Xfce Power Manager, KDE Connect, Alacritty+tmux

## NixOS Integration Pattern

For Nix store packages (Nushell example):

```nu
# Resolve symlink to actual Nix store path
let resolved_path = (readlink -f /run/current-system/sw/path/to/file | str trim)

# Create direct symlink to store path
ln -sf $resolved_path ~/.config/target/location

# Enable and start systemd user service
systemctl --user daemon-reload
systemctl --user enable service-name.service
```

This pattern ensures symlinks track NixOS package updates across generations.

## Template Variables

Common chezmoi variables used:

- `{{ .chezmoi.homeDir }}` - User's home directory
- `{{ .chezmoi.os }}` - Operating system
- `{{ if stat "/path" }}` - Conditional execution

## Adding New Scripts

1. Choose appropriate prefix (run_once_, run_onchange_, run_after_)
2. Add `.tmpl` suffix if using templates
3. Make script idempotent
4. Use `set -euo pipefail` for safety
5. Add clear echo statements for user feedback

## Debugging Scripts

### Force Re-run

```bash
# Clear specific script state
chezmoi state delete --bucket=scriptState --key=script-name

# Clear all run_once_ scripts
chezmoi state delete-bucket --bucket=scriptState
```

### Test Script

```bash
chezmoi execute-template < script.tmpl | bash -x
```

## Best Practices

- Always check if files/commands exist before using
- Use absolute paths or chezmoi variables
- Provide user feedback with echo statements
- Handle errors gracefully
- Make scripts work on fresh systems
